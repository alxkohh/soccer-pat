﻿/*
	Model for a simplified football match.
	Approach is high level, looking at teamA vs teamB, not looking at individual footballers.

	Some assumptions / simplified rules for our football match:

	1. Ball does not go out of bounds
	2. No fouls committed
	3. Shots are not blocked by defenders. It is always the goalkeeper that tries to save the shot.
	4. Players will never pass or dribble backwards
*/

#import "PAT.Lib.Football";

// changed. previously teamA is 1, teamB is 2
#define teamA 0;
#define teamB 1;
// simplified football pitch, only 4 zones. A large value would mean closer proximity to teamB's goalpost.

#define zones 5;
#define teamA_penalty_box 1;	// teamA's goalpost is inside this zone
var teamA_midfield_zone = (zones-1)/2;
var teamB_midfield_zone = (zones+1)/2;
#define teamB_penalty_box zones-1;	// teamB's goalpost is inside this zone

#define time_limit 40;
var time = 0;

var ball_loc = teamA_midfield_zone;	// for the case where teamA starts the match

var s_pass_score = [100, 100];
var l_pass_score = [100, 100];
var s_intercept_score = [100, 100];
var l_intercept_score = [100, 100];
var shoot_score = [100, 100];
var save_score = [100, 100];
var dribble_score = [100, 100];
var tackle_score = [100, 100];

hvar tmp;


/* 
	A few of the popular attack strategies used by teams in real life (past | present).

	tiki taka - quick short passes (barcelona, arsenal | man city)
	route one - long ball upfield, eg. to target man (england, stoke city | many weak teams)
	star dribbler - pass the ball to star dribbler, watch him weave through opponents (messi, ronaldo, hazard | neymar, mbappe, son)
	
	For our model, star dribbler is the best strategy. route one is the worst. -> Same as real life
*/
#define tiki_taka 1000;
#define route_one 2000;
#define star_dribbler 3000;

// Set each team's attack strategy
var teamA_attack_strategy = route_one;
var teamB_attack_strategy = tiki_taka;

var teamA_score = 0;
var teamB_score = 0;

#define timeout time == time_limit;
#define match_end timeout;

#define teamA_win match_end && teamA_score > teamB_score;
#define teamB_win match_end && teamA_score < teamB_score;
#define draw match_end && teamA_score == teamB_score;



// With all the variables and macros out of the way, the model begins now

teamA_attack = attack(teamA);
teamB_attack = attack(teamB);

attack(attacking_team) = timer { time++; } -> (
	[!match_end] case {
		attacking_team == teamA: attack_with_strategy(teamA, teamA_attack_strategy)
		attacking_team == teamB: attack_with_strategy(teamB, teamB_attack_strategy)
		default: Skip	// error case! 
	} []
	[match_end] Skip 
);

attack_with_strategy(attacking_team, attack_strategy) = case {
	
	attack_strategy == tiki_taka: attack_tiki_taka(attacking_team)
	attack_strategy == route_one: attack_route_one(attacking_team)
	attack_strategy == star_dribbler: attack_star_dribbler(attacking_team)
	default: Skip	// error case!
};

attack_tiki_taka(attacking_team) = pcase {

	5 : stay -> attack(attacking_team)
	10: run -> attack(attacking_team)
	50: short_pass -> intercept_short_pass( call(opponent_of, attacking_team) )
	5 : long_pass -> intercept_long_pass( call(opponent_of, attacking_team) )
	10: dribble -> tackle( call(opponent_of, attacking_team) )
	20: shoot -> goalkeeper_save( call(opponent_of, attacking_team) )
};

attack_route_one(attacking_team) = pcase {

	10: stay -> attack(attacking_team)
	10: run -> attack(attacking_team)
	5 : short_pass -> intercept_short_pass( call(opponent_of, attacking_team) )
	50: long_pass -> intercept_long_pass( call(opponent_of, attacking_team) )
	5 : dribble -> tackle( call(opponent_of, attacking_team) )
	20: shoot -> goalkeeper_save( call(opponent_of, attacking_team) )
};

attack_star_dribbler(attacking_team) = pcase {

	5 : stay -> attack(attacking_team)
	20: run -> attack(attacking_team)
	20: short_pass -> intercept_short_pass( call(opponent_of, attacking_team) )		// read as "opponent of the attacking team"
	5 : long_pass -> intercept_long_pass( call(opponent_of, attacking_team) )
	30: dribble -> tackle( call(opponent_of, attacking_team) )
	20: shoot -> goalkeeper_save( call(opponent_of, attacking_team) )
};

/*
	Four types of defenses. All of them can fail to materialise.
	
	Currently, intercept_short_pass and tackle share the same implementation

	Note:
	For our context, there is no concept called "defending_strategy".
	Because a defending action is really just to counter against a specific type of attacking action.
	eg. tackle against a dribble, etc
*/

intercept_long_pass(defending_team) = {tmp = 100 - call(long_pass_success_rate, defending_team, ball_loc, l_pass_score[1-defending_team], l_intercept_score[defending_team]);} -> pcase {
	tmp	  		: succeed -> attack(defending_team)	// change of possession
	100 - tmp	: fail { ball_loc = call(ball_move_forward, call(opponent_of, defending_team), 2, ball_loc) } -> attack( call(opponent_of, defending_team) ) 	// NO change of possession, ball move forward
};


intercept_short_pass(defending_team) = {tmp = 100 - call(short_pass_success_rate, defending_team, ball_loc, s_pass_score[1-defending_team], s_intercept_score[defending_team]);} -> pcase {
	tmp	  		: succeed -> attack(defending_team)	// change of possession
	100 - tmp	: fail { ball_loc = call(ball_move_forward, call(opponent_of, defending_team), 1, ball_loc) } -> attack( call(opponent_of, defending_team) ) 	// NO change of possession, ball move forward
};

tackle(defending_team) = {tmp = 100 - call(dribble_success_rate, defending_team, ball_loc, dribble_score[1-defending_team], tackle_score[defending_team]);} -> pcase {
	tmp			: succeed -> attack(defending_team)	// change of possession
	100 - tmp	: fail { ball_loc = call(ball_move_forward, call(opponent_of, defending_team), 1, ball_loc) }-> attack( call(opponent_of, defending_team) ) 	// NO change of possession, ball move forward
};

goalkeeper_save(defending_team) = {tmp = 100 - call(shoot_success_rate, defending_team, ball_loc, shoot_score[1-defending_team], save_score[defending_team]);} -> pcase {

	call(success_rate, defending_team, ball_loc)	  : succeed -> attack(defending_team)	// change of possession
	100 - call(success_rate, defending_team, ball_loc): 
	fail {

		//if (teamA_score - teamB_score < -3 || teamA_score - teamB_score > 3) goalSkip = true;  
		if(defending_team == teamB) { teamA_score++;ball_loc=teamB_midfield_zone; } else { teamB_score++;ball_loc=teamA_midfield_zone; };
		} -> attack(defending_team)
};



// Run a few assertions, to test the model above


teamA_start = { ball_loc = teamA_midfield_zone; call(setZones, zones); } -> teamA_attack;
teamB_start = { ball_loc = teamB_midfield_zone; call(setZones, zones); } -> teamB_attack;

#assert teamA_start reaches teamA_win with prob;
#assert teamA_start reaches teamB_win with prob;
#assert teamA_start reaches draw with prob;

#assert teamB_start reaches teamA_win with prob;
#assert teamB_start reaches teamB_win with prob;
#assert teamB_start reaches draw with prob;

coin_toss = pcase {
	50: teamA_start
	50: teamB_start
};

#define teamA_score_below_four teamA_score < 4 && match_end;

#assert coin_toss reaches teamA_win with prob;
#assert coin_toss reaches teamB_win with prob;
#assert coin_toss reaches draw with prob;
#assert coin_toss reaches teamA_score_below_four with prob;