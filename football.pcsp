﻿/*
	Model for a simplified football match.
	Approach is high level, looking at teamA vs teamB, not looking at individual footballers.

	Some assumptions / simplified rules for our football match:

	1. Ball does not go out of bounds
	2. No fouls committed
	3. Shots are not blocked by defenders. It is always the goalkeeper that tries to save the shot.
	4. Players will never pass or dribble backwards
*/

#import "PAT.Lib.Football";

// changed. previously teamA is 1, teamB is 2
#define teamA -1;
#define teamB 1;
// simplified football pitch, only 4 zones. A large value would mean closer proximity to teamB's goalpost.

#define teamA_penalty_box 20;	// teamA's goalpost is inside this zone
#define teamA_midfield_zone 40;
#define teamB_midfield_zone 60;
#define teamB_penalty_box 80;	// teamB's goalpost is inside this zone

#define time_limit 30;
var time = 0;

var ball_loc = teamA_midfield_zone;	// for the case where teamA starts the match


/* 
	A few of the popular attack strategies used by teams in real life (past | present).

	tiki taka - quick short passes (barcelona, arsenal | man city)
	route one - long ball upfield, eg. to target man (england, stoke city | many weak teams)
	star player - pass the ball to star player, watch him work his magic (messi, ronaldo, hazard | neymar, mbappe, son)
	
	For our model, star player is the best strategy. route one is the worst. -> Same as real life
*/
#define tiki_taka 1000;
#define route_one 2000;
#define star_player 3000;

// Set each team's attack strategy
var teamA_attack_strategy = route_one;
var teamB_attack_strategy = tiki_taka;

var teamA_score = 0;
var teamB_score = 0;
//hvar goalSkip = false;

#define timeout time == time_limit;
#define match_end timeout;

#define teamA_win match_end && teamA_score > teamB_score;
#define teamB_win match_end && teamA_score < teamB_score;
#define draw match_end && teamA_score == teamB_score;



// With all the variables and macros out of the way, the model begins now

teamA_attack = attack(teamA);
teamB_attack = attack(teamB);

attack(attacking_team) = timer { time++; } -> (
	[!match_end] case {
		attacking_team == teamA: attack_with_strategy(teamA, teamA_attack_strategy)
		attacking_team == teamB: attack_with_strategy(teamB, teamB_attack_strategy)
		default: Skip	// error case! 
	} []
	[match_end] Skip 
);

attack_with_strategy(attacking_team, attack_strategy) = case {
	
	attack_strategy == tiki_taka: attack_tiki_taka(attacking_team)
	attack_strategy == route_one: attack_route_one(attacking_team)
	attack_strategy == star_player: attack_star_player(attacking_team)
	default: Skip	// error case!
};

attack_tiki_taka(attacking_team) = pcase {

	5 : stay -> attack(attacking_team)
	10: run -> attack(attacking_team)
	50: short_pass -> intercept_short_pass( call(opponent_of, attacking_team) )
	5 : long_pass -> intercept_long_pass( call(opponent_of, attacking_team) )
	10: dribble -> tackle( call(opponent_of, attacking_team) )
	20: shoot -> goalkeeper_save( call(opponent_of, attacking_team) )
};

attack_route_one(attacking_team) = pcase {

	10: stay -> attack(attacking_team)
	10: run -> attack(attacking_team)
	5 : short_pass -> intercept_short_pass( call(opponent_of, attacking_team) )
	50: long_pass -> intercept_long_pass( call(opponent_of, attacking_team) )
	5 : dribble -> tackle( call(opponent_of, attacking_team) )
	20: shoot -> goalkeeper_save( call(opponent_of, attacking_team) )
};

attack_star_player(attacking_team) = pcase {

	5 : stay -> attack(attacking_team)
	20: run -> attack(attacking_team)
	20: short_pass -> intercept_short_pass( call(opponent_of, attacking_team) )		// read as "opponent of the attacking team"
	5 : long_pass -> intercept_long_pass( call(opponent_of, attacking_team) )
	30: dribble -> tackle( call(opponent_of, attacking_team) )
	20: shoot -> goalkeeper_save( call(opponent_of, attacking_team) )
};

/*
	Four types of defenses. All of them can fail to materialise.
	
	Currently, intercept_short_pass and tackle share the same implementation

	Note:
	For our context, there is no concept called "defending_strategy".
	Because a defending action is really just to counter against a specific type of attacking action.
	eg. tackle against a dribble, etc
*/

intercept_long_pass(defending_team) = pcase {
	
	call(success_rate, defending_team, ball_loc)	  : succeed -> attack(defending_team)	// change of possession
	100 - call(success_rate, defending_team, ball_loc): fail { ball_loc = call(ball_move_forward, call(opponent_of, defending_team), 2, ball_loc) } -> attack( call(opponent_of, defending_team) ) 	// NO change of possession, ball move forward
};


intercept_short_pass(defending_team) = pcase {
	
	call(success_rate, defending_team, ball_loc)	  : succeed -> attack(defending_team)	// change of possession
	100 - call(success_rate, defending_team, ball_loc): fail { ball_loc = call(ball_move_forward, call(opponent_of, defending_team), 1, ball_loc) } -> attack( call(opponent_of, defending_team) ) 	// NO change of possession, ball move forward
};

tackle(defending_team) = pcase {
	
	call(success_rate, defending_team, ball_loc)	  : succeed -> attack(defending_team)	// change of possession
	100 - call(success_rate, defending_team, ball_loc): fail { ball_loc = call(ball_move_forward, call(opponent_of, defending_team), 1, ball_loc) }-> attack( call(opponent_of, defending_team) ) 	// NO change of possession, ball move forward
};

goalkeeper_save(defending_team) = pcase {

	call(success_rate, defending_team, ball_loc)	  : succeed -> attack(defending_team)	// change of possession
	100 - call(success_rate, defending_team, ball_loc): 
	fail {

		//if (teamA_score - teamB_score < -3 || teamA_score - teamB_score > 3) goalSkip = true;  
		if(defending_team == teamB) { teamA_score++;ball_loc=teamB_midfield_zone; } else { teamB_score++;ball_loc=teamA_midfield_zone; };
		} -> attack(defending_team)
};



// Run a few assertions, to test the model above

teamA_start = { ball_loc = teamA_midfield_zone } -> teamA_attack;
teamB_start = { ball_loc = teamB_midfield_zone } -> teamB_attack;

#assert teamA_start reaches teamA_win with prob;
#assert teamA_start reaches teamB_win with prob;
#assert teamA_start reaches draw with prob;

#assert teamB_start reaches teamA_win with prob;
#assert teamB_start reaches teamB_win with prob;
#assert teamB_start reaches draw with prob;

coin_toss = pcase {
	50: teamA_start
	50: teamB_start
};

#assert coin_toss reaches teamA_win with prob;
#assert coin_toss reaches teamB_win with prob;
#assert coin_toss reaches draw with prob;