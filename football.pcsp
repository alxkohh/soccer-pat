﻿/*
	Model for a simplified football match.
	Approach is high level, looking at teamA vs teamB, not looking at individual footballers.

	Some assumptions / simplified rules for our football match:

	1. First team to score wins the entire match
	2. teamA kicks off the match
	3. Ball does not go out of bounds
	4. No fouls committed
	5. Shots are not blocked by defenders. It is always the goalkeeper that tries to save the shot.
	6. Players will never pass or dribble backwards
	7. All players are identical
*/

#import "PAT.Lib.Football";

// changed. previously teamA is 1, teamB is 2
#define teamA -1;
#define teamB 1;

// simplified football pitch, only 4 zones. A large value would mean closer proximity to teamB's goalpost.

#define teamA_penalty_box 20;	// teamA's goalpost is inside this zone
#define teamA_midfield_zone 40;
#define teamB_midfield_zone 60;
#define teamB_penalty_box 80;	// teamB's goalpost is inside this zone

// no winner yet at the start
var winner = 0;

#define time_limit 360; // each time unit is 15s
hvar time = 0;

#define teamA_win winner == teamA;
#define teamB_win winner == teamB;
#define timeout time == time_limit;

var ball_loc = teamA_midfield_zone;	// initial ball location is team A midfield zone, because teamA starts the match


/* 
	Famous football strategies, can do a simple google search to find out!
	I used 1000 2000 etc to avoid clashing with values declared on top.
	
	TODO: add more strategies! -> Alex
*/
#define tiki_taka 1000;		// quick short passes
#define route_one 2000;		// whack the ball upfield, basically long pass tactic

/* 
	Attack strategy used by each team.
	The good thing about this design is we can conveniently do re-assignment
	on this 2 global vars.
*/
var teamA_attack_strategy = tiki_taka;
var teamB_attack_strategy = route_one;


// With all the variables and macros out of the way, the model begins now

teamA_attack = attack(teamA);
teamB_attack = attack(teamB);

attack(attacking_team) = timer{time++;} -> (
	[time < time_limit] case {
		attacking_team == teamA: attack_with_strategy(teamA, teamA_attack_strategy)
		attacking_team == teamB: attack_with_strategy(teamB, teamB_attack_strategy)
		default				   : Skip	// error case! 
	} []
	[time == time_limit] Skip
);

attack_with_strategy(attacking_team, attack_strategy) = case {
	
	attack_strategy == tiki_taka: attack_tiki_taka(attacking_team)
	attack_strategy == route_one: attack_route_one(attacking_team)
	default						: Skip	// error case!
};

attack_tiki_taka(attacking_team) = pcase {

	5 : stay -> attack_tiki_taka(attacking_team)
	10: run -> attack_tiki_taka(attacking_team)
	50: short_pass -> intercept_short_pass( call(opponent_of, attacking_team) )		// read as "opponent of the attacking team"
	5 : long_pass -> intercept_long_pass( call(opponent_of, attacking_team) )
	10: dribble -> tackle( call(opponent_of, attacking_team) )
	20: shoot -> goalkeeper_save( call(opponent_of, attacking_team) )
	
	/* 
		Alfred: consider doing 
		
		5: stay { teamA_strategy = route_one } -> attack(attacking_team)
		
		to tweak the strategy midway through the game
	*/
};

attack_route_one(attacking_team) = pcase {

	10: stay -> attack_route_one(attacking_team)
	10: run -> attack_route_one(attacking_team)
	5 : short_pass -> intercept_short_pass( call(opponent_of, attacking_team) )
	50: long_pass -> intercept_long_pass( call(opponent_of, attacking_team) )
	5 : dribble -> tackle( call(opponent_of, attacking_team) )
	20: shoot -> goalkeeper_save( call(opponent_of, attacking_team) )
};


/*
	Four types of defenses. All of them can fail to materialise.
	
	Currently, intercept_short_pass and tackle share the same implementation

	Note:
	For our context, there is no concept called "defending_strategy". And, we should probably leave it at that.
	Because a defending action is really just to counter against a specific type of attacking action.
	eg. tackle against a dribble, etc
	
	^ More on the football talk can be done over discord but for now let's not add defending strategies.
*/

intercept_long_pass(defending_team) = pcase {
	
	call(success_rate, defending_team, ball_loc)	  : succeed -> attack(defending_team)	// change of possession
	100 - call(success_rate, defending_team, ball_loc): fail { ball_loc = call(ball_move_forward, call(opponent_of, defending_team), 2, ball_loc) } -> attack( call(opponent_of, defending_team) ) 	// NO change of possession, ball move forward
};


intercept_short_pass(defending_team) = pcase {
	
	call(success_rate, defending_team, ball_loc)	  : succeed -> attack(defending_team)	// change of possession
	100 - call(success_rate, defending_team, ball_loc): fail { ball_loc = call(ball_move_forward, call(opponent_of, defending_team), 1, ball_loc) } -> attack( call(opponent_of, defending_team) ) 	// NO change of possession, ball move forward
};

tackle(defending_team) = pcase {
	
	call(success_rate, defending_team, ball_loc)	  : succeed -> attack(defending_team)	// change of possession
	100 - call(success_rate, defending_team, ball_loc): fail { ball_loc = call(ball_move_forward, call(opponent_of, defending_team), 1, ball_loc) }-> attack( call(opponent_of, defending_team) ) 	// NO change of possession, ball move forward
};

goalkeeper_save(defending_team) = pcase {

	call(success_rate, defending_team, ball_loc)	  : succeed -> attack(defending_team)	// change of possession
	100 - call(success_rate, defending_team, ball_loc): fail { winner = call(opponent_of, defending_team) } -> Skip	// game ends because first team to score wins
	
	// Qing Zhou: Consider incrementing the goal count in the 'fail' case. (Instead of ending the game)
};


// Run a few assertions, to test the model above

teamA_start = { ball_loc = teamA_midfield_zone } -> teamA_attack;
teamB_start = { ball_loc = teamB_midfield_zone } -> teamB_attack;

#assert teamA_start reaches teamA_win with prob;
#assert teamB_start reaches teamB_win with prob;

coin_toss = pcase {
	50: teamA_start
	50: teamB_start
};

#assert coin_toss reaches teamA_win with prob;
#assert coin_toss reaches teamB_win with prob;

#assert coin_toss reaches timeout with prob;